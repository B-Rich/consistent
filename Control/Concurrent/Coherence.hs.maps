{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

module Control.Concurrent.Coherence where

import Control.Applicative
import Control.Concurrent
import Control.Concurrent.Async.Lifted
import Control.Concurrent.STM
import Control.Exception.Lifted (bracket_)
import Control.Monad hiding (forM_, mapM_)
import Control.Monad.Base
import Control.Monad.IO.Class
import Control.Monad.Loops
import Control.Monad.Reader.Class
import Control.Monad.Trans.Control
import Control.Monad.Trans.Reader (ReaderT(..), runReaderT)
import Data.HashMap.Strict as Map
import Prelude hiding (log, mapM_)
import System.Mem.StableName
import Unsafe.Coerce (unsafeCoerce)

data CVar a = CVar
    { cvVars     :: TVar a
    , cvModified :: TVar (Maybe ThreadId)
    }

data CoherenceMap = forall a. CoherenceMap
    (TVar (HashMap ThreadId (TVar (HashMap (StableName (CVar a)) (CVar a)))))

data CoherenceState = CoherenceState
    { csJournal    :: TQueue (STM ())
    , csSyncVar    :: TVar Bool
    , csThreadVars :: CoherenceMap
    }

newtype CoherenceT m a = CoherenceT
    { runCoherenceT :: ReaderT CoherenceState m a }
    deriving (Functor, Applicative, Monad, MonadIO)

instance MonadBase IO m => MonadBase IO (CoherenceT m) where
    liftBase b = CoherenceT $ liftBase b

instance MonadBaseControl IO m => MonadBaseControl IO (CoherenceT m) where
    newtype StM (CoherenceT m) a =
        StMCoherenceT (StM (ReaderT CoherenceState m) a)
    liftBaseWith f =
        CoherenceT $ liftBaseWith $ \runInBase -> f $ \k ->
            liftM StMCoherenceT $ runInBase $ runCoherenceT k
    restoreM (StMCoherenceT m) = CoherenceT . restoreM $ m

runCoherently :: (MonadBaseControl IO m, MonadIO m) => CoherenceT m a -> m a
runCoherently action = do
    cs <- liftIO $ do
        m  <- newTQueueIO
        v  <- newTVarIO False
        vs <- newTVarIO Map.empty
        return $ CoherenceState m v (CoherenceMap vs)

    flip runReaderT cs $ withAsync applyChanges $ \worker -> do
        link worker
        runCoherenceT action
  where
    applyChanges = do
        CoherenceState {..} <- ask
        liftIO $ forever $ atomically $ do
            sv <- readTVar csSyncVar
            check (not sv)
            mt <- isEmptyTQueue csJournal
            check (not mt)

            -- Only process 10 actions from the queue at a time, to make sure
            -- we don't try to do too much and end up getting starved.
            replicateM_ 10 $ do
                mt' <- isEmptyTQueue csJournal
                unless mt' $ join $ readTQueue csJournal

newCVar :: MonadIO m => a -> CoherenceT m (CVar a)
newCVar a = CoherenceT $ do
    CoherenceState {..} <- ask
    liftIO $ do
        tid  <- myThreadId
        cv   <- atomically $ CVar <$> newTVar a <*> newTVar Nothing
        name <- makeStableName cv
        atomically $ do
            cv <- CVar <$> newTVar a <*> newTVar Nothing
            case csThreadVars of
                CoherenceMap mv -> do
                    m <- readTVar mv
                    case Map.lookup tid m of
                        Nothing -> do
                            m' <- newTVar (Map.singleton name cv)
                            modifyTVar mv (Map.insert tid (unsafeCoerce m'))
                        Just tvs ->
                            modifyTVar tvs (Map.insert (unsafeCoerce name) (unsafeCoerce cv))
            return cv

readCVar :: MonadIO m => CVar a -> CoherenceT m a
readCVar (CVar v _) = CoherenceT $ liftIO $ readTVarIO v

writeCVar :: MonadIO m => CVar a -> a -> CoherenceT m ()
writeCVar cv@(CVar v vmod) a = CoherenceT $ do
    CoherenceState {..} <- ask
    liftIO $ do
        tid  <- myThreadId
        name <- makeStableName cv
        atomically $ do
            m <- readTVar vmod
            case m of
                Just other | other /= tid ->
                    error "Modified the same CVar in multiple coherent blocks"
                _ -> do
                    writeTVar v a
                    writeTVar vmod (Just tid)
                    writeTQueue csJournal (apply tid name csThreadVars)
  where
    apply tid name (CoherenceMap vars) = do
        val <- readTVar v
        vs  <- readTVar vars
        foldlWithKey'
            (\f other tvs -> f >>
              unless (other == tid)
                  (do vars <- readTVar tvs
                      case Map.lookup name vars of
                          Nothing         -> error "wut?"
                          Just (CVar o _) -> writeTVar o val))
            (return ())
            (unsafeCoerce vs)
        writeTVar vmod Nothing

coherently :: (MonadBaseControl IO m, MonadIO m)
           => CoherenceT m a -> CoherenceT m a
coherently (CoherenceT f) = CoherenceT $ do
    CoherenceState {..} <- ask
    bracket_
        (liftIO $ atomically $ writeTVar csSyncVar True)
        (liftIO $ atomically $ writeTVar csSyncVar False) f

main :: IO ()
main = runCoherently $ do
    v <- newCVar (10 :: Int)
    u <- newCVar (20 :: Int)
    withAsync (worker v u) $ \thread -> do
        replicateM_ 30 $ do
            liftIO $ print "parent before"
            coherently $ do
                x <- readCVar v
                writeCVar u 100
                writeCVar v 300
                liftIO $ print $ "parent: " ++ show x
            liftIO $ print "parent end"
            liftIO $ threadDelay 50000
        wait thread
    return ()
  where
    worker v u = do
        liftIO $ threadDelay 100000
        replicateM_ 30 $ do
            liftIO $ print "child before"
            coherently $ do
                x <- readCVar u
                writeCVar v 200
                liftIO $ print $ "child: " ++ show x
            liftIO $ print "child before"
            liftIO $ threadDelay 450000
